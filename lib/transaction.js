// Generated by CoffeeScript 1.8.0
(function() {
  var Match, Neo4jCursor, Neo4jTransaction, check, events, _, __error, __wait, _ref, _ref1;

  _ref = require('./helpers'), events = _ref.events, _ = _ref._, __wait = _ref.__wait, __error = _ref.__error;

  _ref1 = require('./check'), check = _ref1.check, Match = _ref1.Match;

  Neo4jCursor = require('./cursor');


  /*
  @locus Server
  @summary Implementation of Transactional Cypher HTTP endpoint
           This class is event-driven and all methods is chainable
           Have to be finished by calling `.commit()` or `.rollback()` method
  @class Neo4jTransaction
  @url http://neo4j.com/docs/2.2.5/rest-api-transactional.html
   */

  module.exports = Neo4jTransaction = (function() {
    Neo4jTransaction.prototype.__proto__ = events.EventEmitter.prototype;

    function Neo4jTransaction(_db, settings, opts) {
      var error, response, statement;
      this._db = _db;
      if (opts == null) {
        opts = {};
      }
      events.EventEmitter.call(this);
      this._ready = false;
      this._results = [];
      this.on('transaction', (function(_this) {
        return function() {
          var cb, _arguments;
          _arguments = arguments;
          cb = arguments[arguments.length - 1];
          if (_this._ready) {
            cb.apply(_this, _arguments);
          } else {
            _this.once('ready', function() {
              return cb.apply(_this, _arguments);
            });
          }
        };
      })(this));
      this.on('ready', (function(_this) {
        return function() {
          return _this._ready = true;
        };
      })(this));
      if (settings) {
        statement = this.__prepare(settings, opts);
      }
      if (!statement) {
        statement = {
          request: []
        };
      }
      try {
        response = this._db.__call(this._db.__service.transaction.endpoint, {
          data: {
            statements: statement.request
          }
        }, 'POST');
        this.__proceedResults(null, response, statement.reactive);
        this._commitURL = response.data.commit;
        this._execURL = response.data.commit.replace('/commit', '');
        this._expiresAt = response.data.transaction.expires;
        this.emit('ready');
      } catch (_error) {
        error = _error;
        this.__proceedResults(error, null, statement.reactive);
      }
    }

    Neo4jTransaction.prototype.__prepare = function(settings, opts, callback, asObj) {
      var cypher, cypherString, fill, reactive, resultDataContents, statements, _i, _len, _ref2;
      if (opts == null) {
        opts = {};
      }
      if (asObj == null) {
        asObj = false;
      }
      _ref2 = this._db.__parseSettings(settings, opts, callback), opts = _ref2.opts, cypher = _ref2.cypher, resultDataContents = _ref2.resultDataContents, reactive = _ref2.reactive, callback = _ref2.callback;
      fill = function(cs) {
        return {
          statement: cs,
          parameters: opts,
          resultDataContents: resultDataContents
        };
      };
      statements = {
        request: [],
        reactive: reactive
      };
      if (_.isArray(cypher)) {
        for (_i = 0, _len = cypher.length; _i < _len; _i++) {
          cypherString = cypher[_i];
          statements.request.push(fill(cypherString));
        }
      } else if (_.isString(cypher)) {
        statements.request.push(fill(cypher));
      }
      if (asObj) {
        return {
          statements: statements,
          callback: callback
        };
      } else {
        return statements;
      }
    };

    Neo4jTransaction.prototype.__commit = function(statement, callback) {
      var data, reactive;
      if (statement) {
        data = {
          data: {
            statements: statement.request
          }
        };
        reactive = statement.reactive;
      } else {
        data = {
          data: {
            statements: []
          }
        };
        reactive = false;
      }
      return this._db.__call(this._commitURL, data, 'POST', (function(_this) {
        return function(error, response) {
          if (statement) {
            _this.__proceedResults(error, response, statement.reactive);
          }
          if (callback != null ? callback["return"] : void 0) {
            return callback["return"](_this._results);
          } else {
            return callback(error, _this._results);
          }
        };
      })(this));
    };

    Neo4jTransaction.prototype.__proceedResults = function(error, response, reactive) {
      if (reactive == null) {
        reactive = false;
      }
      if (!error) {
        return this._db.__cleanUpResponse(response, (function(_this) {
          return function(result) {
            return _this._results.push(new Neo4jCursor(_this._db.__transformData(result, reactive)));
          };
        })(this));
      } else {
        return __error(new Error(error));
      }
    };


    /*
    @locus Server
    @summary Rollback an open transaction
    @name rollback
    @class Neo4jTransaction
    @url http://neo4j.com/docs/2.2.5/rest-api-transactional.html#rest-api-rollback-an-open-transaction
    @returns {undefined}
     */

    Neo4jTransaction.prototype.rollback = function() {
      return __wait((function(_this) {
        return function(fut) {
          return _this.emit('transaction', fut, function(fut) {
            return this._db.__call(this._execURL, null, 'DELETE', (function(_this) {
              return function() {
                _this._results = [];
                return fut["return"](void 0);
              };
            })(this));
          });
        };
      })(this));
    };


    /*
    @locus Server
    @summary Reset transaction timeout of an open Neo4j Transaction
    @name resetTimeout
    @class Neo4jTransaction
    @url http://neo4j.com/docs/2.2.5/rest-api-transactional.html#rest-api-reset-transaction-timeout-of-an-open-transaction
    @returns Neo4jTransaction
     */

    Neo4jTransaction.prototype.resetTimeout = function() {
      return __wait((function(_this) {
        return function(fut) {
          return _this.emit('transaction', fut, function(fut) {
            return this._db.__call(this._execURL, {
              data: {
                statements: []
              }
            }, 'POST', (function(_this) {
              return function(error, response) {
                _this._expiresAt = response.data.transaction.expires;
                return fut["return"](_this);
              };
            })(this));
          });
        };
      })(this));
    };


    /*
    @locus Server
    @summary Execute statement in open Neo4j Transaction
    @name execute
    @class Neo4jTransaction
    @url http://neo4j.com/docs/2.2.5/rest-api-transactional.html#rest-api-execute-statements-in-an-open-transaction
    @param {Object | String | [String]} settings - Cypher query as String or Array of Cypher queries or object of settings
    @param {String | [String]} settings.cypher - Cypher query(ies), alias: `settings.query`
    @param {Object}   settings.opts - Map of cypher query(ies) parameters, aliases: `settings.parameters`, `settings.params`
    @param {[String]} settings.resultDataContents - Array of contents to return from Neo4j, like: 'REST', 'row', 'graph'. Default: `['REST']`
    @param {Boolean}  settings.reactive - Reactive nodes updates on Neo4jCursor.fetch(). Default: `false`. Alias: `settings.reactiveNodes`
    @param {Object}   opts - Map of cypher query(ies) parameters
    @returns {Neo4jTransaction}
     */

    Neo4jTransaction.prototype.execute = function(settings, opts) {
      if (opts == null) {
        opts = {};
      }
      return __wait((function(_this) {
        return function(fut) {
          return _this.emit('transaction', _this.__prepare(settings, opts), fut, function(statement, fut) {
            return this._db.__call(this._execURL, {
              data: {
                statements: statement.request
              }
            }, 'POST', (function(_this) {
              return function(error, response) {
                _this.__proceedResults(error, response, statement.reactive);
                return fut["return"](_this);
              };
            })(this));
          });
        };
      })(this));
    };


    /*
    @locus Server
    @summary Commit Neo4j Transaction
    @name commit
    @class Neo4jTransaction
    @url http://neo4j.com/docs/2.2.5/rest-api-transactional.html#rest-api-commit-an-open-transaction
    @param {Function | Object | String | [String]} settings - Cypher query as String or Array of Cypher queries or object of settings
    @param {String | [String]} settings.cypher - Cypher query(ies), alias: `settings.query`
    @param {Object}   settings.opts - Map of cypher query(ies) parameters, aliases: `settings.parameters`, `settings.params`
    @param {[String]} settings.resultDataContents - Array of contents to return from Neo4j, like: 'REST', 'row', 'graph'. Default: `['REST']`
    @param {Boolean}  settings.reactive - Reactive nodes updates on Neo4jCursor.fetch(). Default: `false`. Alias: `settings.reactiveNodes`
    @param {Function} settings.callback - Callback function. If passed, the method runs asynchronously. Alias: `settings.cb`
    @param {Object}   opts - Map of cypher query(ies) parameters
    @param {Function} callback - Callback function. If passed, the method runs asynchronously.
    @returns {[Neo4jCursor]} - Array of Neo4jCursor(s), or empty array if no nodes was returned during Transaction
     */

    Neo4jTransaction.prototype.commit = function(settings, opts, callback) {
      var statements, _ref2;
      if (opts == null) {
        opts = {};
      }
      if (settings) {
        _ref2 = this.__prepare(settings, opts, callback, true), statements = _ref2.statements, callback = _ref2.callback;
      }
      if (!callback) {
        return __wait((function(_this) {
          return function(fut) {
            return _this.emit('transaction', statements, fut, _this.__commit);
          };
        })(this));
      } else {
        this.emit('transaction', statements, callback, this.__commit);
      }
    };


    /*
    @locus Server
    @summary Get current data in Neo4j Transaction
    @name current
    @class Neo4jTransaction
    @returns {[Neo4jCursor]} - Array of Neo4jCursor(s), or empty array if no nodes was returned during Transaction
     */

    Neo4jTransaction.prototype.current = function() {
      return this._results;
    };


    /*
    @locus Server
    @summary Get last received data in Neo4j Transaction
    @name last
    @class Neo4jTransaction
    @returns {Neo4jCursor | null} - Neo4jCursor, or null if no nodes was returned during Transaction
     */

    Neo4jTransaction.prototype.last = function() {
      if (this._results.length > 0) {
        return this._results[this._results.length - 1];
      } else {
        return null;
      }
    };

    return Neo4jTransaction;

  })();

}).call(this);
