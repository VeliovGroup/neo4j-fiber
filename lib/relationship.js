// Generated by CoffeeScript 1.8.0
(function() {
  var Match, Neo4jData, Neo4jRelationship, check, events, _, __error, __wait, _ref, _ref1,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  _ref = require('./helpers'), events = _ref.events, _ = _ref._, __wait = _ref.__wait, __error = _ref.__error;

  _ref1 = require('./check'), check = _ref1.check, Match = _ref1.Match;

  Neo4jData = require('./data');


  /*
  @locus Server
  @url http://neo4j.com/docs/2.2.5/rest-api-relationships.html
  @summary Represents Relationship API(s)
           Most basic way to work with relationships
           Might be reactive data source, if `_isReactive` passed as `true` - data of relationship will be updated before returning
  
           First argument must be number (id) or object returned from db
           This class is event-driven and all methods is chainable
  @class Neo4jRelationship
   */

  module.exports = Neo4jRelationship = (function(_super) {
    __extends(Neo4jRelationship, _super);

    _.extend(Neo4jRelationship.prototype, events.EventEmitter.prototype);

    function Neo4jRelationship(_db, _id, _isReactive) {
      var _ref2, _ref3;
      this._db = _db;
      this._id = _id;
      this._isReactive = _isReactive != null ? _isReactive : false;
      events.EventEmitter.call(this);
      this._ready = false;
      this.on('ready', (function(_this) {
        return function(relationship) {
          if (relationship && !_.isEmpty(relationship)) {
            _this._id = relationship.id || relationship.metadata.id;
            Neo4jRelationship.__super__.constructor.call(_this, _this._db.__parseNode(relationship), _this._isReactive);
            return _this._ready = true;
          }
        };
      })(this));
      if (_.isObject(this._id)) {
        if (((_ref2 = this._id) != null ? _ref2.startNode : void 0) || ((_ref3 = this._id) != null ? _ref3.start : void 0)) {
          this.emit('ready', this._id);
        } else {
          __error("Relationship is not created or created wrongly, `startNode` or `start` is not returned!");
        }
      } else if (_.isNumber(this._id)) {
        this._db.__batch({
          method: 'GET',
          to: '/relationship/' + this._id
        }, (function(_this) {
          return function(error, relationship) {
            return _this.emit('ready', relationship);
          };
        })(this), this._isReactive, true);
      }
      this.index._current = this;
      this.properties = this.__properties();
    }

    Neo4jRelationship.prototype.__return = function(cb) {
      return __wait((function(_this) {
        return function(fut) {
          if (_this._ready) {
            return cb.call(_this, fut);
          } else {
            return _this.once('ready', function() {
              return cb.call(_this, fut);
            });
          }
        };
      })(this));
    };


    /*
    @locus Server
    @summary Get relationship data
    @name get
    @class Neo4jRelationship
    @url http://neo4j.com/docs/2.2.5/rest-api-relationships.html#rest-api-get-relationship-by-id
    @returns {Object}
     */

    Neo4jRelationship.prototype.get = function() {
      return this.__return(function(fut) {
        return fut["return"](Neo4jRelationship.__super__.get.apply(this, arguments));
      });
    };


    /*
    @locus Server
    @summary Delete relationship
    @name delete
    @class Neo4jRelationship
    @url http://neo4j.com/docs/2.2.5/rest-api-relationships.html#rest-api-delete-relationship
    @returns {undefined}
     */

    Neo4jRelationship.prototype["delete"] = function() {
      return this.__return(function(fut) {
        this._db.__batch({
          method: 'DELETE',
          to: this._service.self.endpoint
        }, function() {}, false, true);
        this.node = void 0;
        return fut["return"](void 0);
      });
    };

    Neo4jRelationship.prototype.__properties = function() {
      return {

        /*
        @locus Server
        @summary Get current relationship's one property or all properties
        @name properties.get
        @class Neo4jRelationship
        @url http://neo4j.com/docs/2.2.5/rest-api-relationships.html#rest-api-get-single-property-on-a-relationship
        @url http://neo4j.com/docs/2.2.5/rest-api-relationships.html#rest-api-get-all-properties-on-a-relationship
        @param {String} name - [OPTIONAL] Name of the property
        @returns {Object | String | Boolean | Number | [String] | [Boolean] | [Number]}
         */
        get: (function(_this) {
          return function(name) {
            return _this.__return(function(fut) {
              this.update();
              if (name) {
                this.update();
                return fut["return"](this.node[name]);
              } else {
                return fut["return"](_.omit(this.node, ['_service', 'id', 'type', 'metadata', 'start', 'end']));
              }
            });
          };
        })(this),

        /*
        @locus Server
        @summary Set (or override, if exists) one property on current relationship
        @name properties.set
        @class Neo4jRelationship
        @url http://neo4j.com/docs/2.2.5/rest-api-relationships.html#rest-api-set-single-property-on-a-relationship
        @param {String | Object} n  - Name or object of key:value pairs
        @param {mix} v - [OPTIONAL] Value of the property
        @returns {Neo4jRelationship}
         */
        set: (function(_this) {
          return function(n, v) {
            return _this.__return(function(fut) {
              var name, nameValue, tasks, value;
              if (_.isObject(n)) {
                nameValue = n;
                check(nameValue, Object);
                tasks = [];
                for (name in nameValue) {
                  value = nameValue[name];
                  check(value, Match.OneOf(String, Number, Boolean, [String], [Number], [Boolean]));
                  this._node[name] = value;
                  tasks.push({
                    method: 'PUT',
                    to: this._service.property.endpoint.replace('{key}', name),
                    body: value
                  });
                }
                this._db.batch(tasks, {
                  plain: true
                }, function() {});
              } else {
                check(n, String);
                check(v, Match.OneOf(String, Number, Boolean, [String], [Number], [Boolean]));
                this._node[n] = v;
                this._db.__batch({
                  method: 'PUT',
                  to: this._service.property.endpoint.replace('{key}', n),
                  body: v
                }, function() {}, false, true);
              }
              return fut["return"](this);
            });
          };
        })(this),

        /*
        @locus Server
        @summary Delete one or all propert(y|ies) by name from a relationship
                 If no argument is passed, - all properties will be removed from the relationship.
        @name properties.delete
        @class Neo4jRelationship
        @url http://neo4j.com/docs/2.2.5/rest-api-relationship-properties.html#rest-api-remove-property-from-a-relationship
        @url http://neo4j.com/docs/2.2.5/rest-api-relationship-properties.html#rest-api-remove-properties-from-a-relationship
        @param {String | [String]} names - Name or array of names of the property
        @returns {Neo4jRelationship}
         */
        "delete": (function(_this) {
          return function(names) {
            check(names, Match.Optional(Match.OneOf(String, [String])));
            return _this.__return(function(fut) {
              var k, name, tasks, v, _i, _len, _ref2, _ref3, _ref4;
              if (_.isString(names)) {
                if ((_ref2 = this._node) != null ? _ref2[names] : void 0) {
                  delete this._node[names];
                  this._db.__batch({
                    method: 'DELETE',
                    to: this._service.property.endpoint.replace('{key}', names)
                  }, function() {}, false, true);
                }
              } else if (_.isArray(names) && names.length > 0) {
                tasks = [];
                for (_i = 0, _len = names.length; _i < _len; _i++) {
                  name = names[_i];
                  if ((_ref3 = this._node) != null ? _ref3[name] : void 0) {
                    delete this._node[name];
                    tasks.push({
                      method: 'DELETE',
                      to: this._service.property.endpoint.replace('{key}', name)
                    });
                  }
                }
                if (tasks.length > 0) {
                  this._db.batch(tasks, {
                    plain: true
                  });
                }
              } else {
                _ref4 = _.omit(this._node, ['_service', 'id', 'type', 'metadata', 'start', 'end']);
                for (k in _ref4) {
                  v = _ref4[k];
                  delete this._node[k];
                }
                this._db.__batch({
                  method: 'DELETE',
                  to: this._service.properties.endpoint
                }, function() {}, false, true);
              }
              return fut["return"](this);
            });
          };
        })(this),

        /*
        @locus Server
        @summary This ~~will replace all existing properties~~ (not actually due to [this bug](https://github.com/neo4j/neo4j/issues/5341)), it will update existing properties and add new.
        @name properties.update
        @class Neo4jRelationship
        @url http://neo4j.com/docs/2.2.5/rest-api-relationships.html#rest-api-set-all-properties-on-a-relationship
        @param {Object} nameValue - Object of key:value pairs
        @returns {Neo4jRelationship}
         */
        update: (function(_this) {
          return function(nameValue) {
            check(nameValue, Object);
            return _this.__return(function(fut) {
              var k, v;
              for (k in nameValue) {
                v = nameValue[k];
                this._node[k] = v;
              }
              this._db.__batch({
                method: 'PUT',
                to: this._service.properties.endpoint,
                body: nameValue
              }, function() {}, false, true);
              return fut["return"](this);
            });
          };
        })(this)
      };
    };


    /*
    @locus Server
    @summary Set / Get property on current relationship, if only first argument is passed - will return property value, if both arguments is presented - property will be updated or created
    @name setProperty
    @class Neo4jRelationship
    @url http://neo4j.com/docs/2.2.5/rest-api-relationships.html#rest-api-get-single-property-on-a-relationship
    @url http://neo4j.com/docs/2.2.5/rest-api-node-properties.html#rest-api-set-property-on-node
    @param {String} name  - Name of the property
    @param {String} value - [OPTIONAL] Value of the property
    @returns {Neo4jRelationship | String | Boolean | Number | [String] | [Boolean] | [Number]}
     */

    Neo4jRelationship.prototype.property = function(name, value) {
      check(name, String);
      if (!value) {
        return this.properties.get(name);
      }
      check(value, Match.Optional(Match.OneOf(String, Number, Boolean, [String], [Number], [Boolean])));
      return this.properties.set(name, value);
    };

    Neo4jRelationship.prototype.index = {

      /*
      @locus Server
      @summary Create index on relationship for type (label)
               This API poorly described in Neo4j Docs, so it may work in some different way - we are expecting
      @name index.create
      @class Neo4jRelationship
      @param {String} label - Label name
      @param {String} key - Index key
      @param {String} type - [OPTIONAL] Indexing type, one of: `exact` or `fulltext`, by default: `exact`
      @returns {Object}
       */
      create: function(label, key, type) {
        if (type == null) {
          type = 'exact';
        }
        check(label, String);
        check(key, String);
        check(type, Match.OneOf('exact', 'fulltext'));
        return this._current._db.__batch({
          method: 'POST',
          to: this._current._db.__service.relationship_index.endpoint + '/' + label,
          body: {
            key: key,
            uri: this._current._service.self.endpoint,
            value: type
          }
        }, void 0, false, true);
      },

      /*
      @locus Server
      @summary Get indexes on relationship for type (label)
               This API poorly described in Neo4j Docs, so it may work in some different way - we are expecting
      @name index.get
      @class Neo4jRelationship
      @param {String} label - Label name
      @param {[String]} key - Index key
      @param {String} type - [OPTIONAL] Indexing type, one of: `exact` or `fulltext`, by default: `exact`
      @returns {Object}
       */
      get: function(label, key, type) {
        if (type == null) {
          type = 'exact';
        }
        check(label, String);
        check(key, String);
        check(type, Match.OneOf('exact', 'fulltext'));
        return this._current._db.__batch({
          method: 'GET',
          to: "" + this._current._db.__service.relationship_index.endpoint + "/" + label + "/" + key + "/" + type + "/" + this._current._id
        }, void 0, false, true);
      },

      /*
      @locus Server
      @summary Drop (remove) index on relationship for type (label)
               This API poorly described in Neo4j Docs, so it may work in some different way - we are expecting
      @name index.drop
      @class Neo4jRelationship
      @param {String} label - Label name
      @param {String} key - Index key
      @param {String} type - [OPTIONAL] Indexing type, one of: `exact` or `fulltext`, by default: `exact`
      @returns {[]} - Empty array
       */
      drop: function(label, key, type) {
        if (type == null) {
          type = 'exact';
        }
        check(label, String);
        check(key, String);
        check(type, Match.OneOf('exact', 'fulltext'));
        return this._current._db.__batch({
          method: 'DELETE',
          to: "" + this._current._db.__service.relationship_index.endpoint + "/" + label + "/" + key + "/" + type + "/" + this._current._id
        }, void 0, false, true);
      }
    };

    return Neo4jRelationship;

  })(Neo4jData);

}).call(this);
