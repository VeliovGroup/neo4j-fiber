// Generated by CoffeeScript 1.8.0
(function() {
  var Match, Neo4jCursor, check, _, __wait, _ref, _ref1;

  _ref = require('./helpers'), _ = _ref._, __wait = _ref.__wait;

  _ref1 = require('./check'), check = _ref1.check, Match = _ref1.Match;


  /*
  @locus Server
  @summary Implementation of cursor for Neo4j results
  @class Neo4jCursor
   */

  module.exports = Neo4jCursor = (function() {
    function Neo4jCursor(_cursor) {
      this._cursor = _cursor;
      this.length = this._cursor.length;
      this._current = 0;
      this.hasNext = this._cursor.length > 1 ? true : false;
      this.hasPrevious = false;
    }

    Neo4jCursor.define('cursor', {
      get: function() {
        return this._cursor;
      },
      set: function() {
        return console.warn("This is not going to work, you trying to reset cursor, make new Cypher query instead");
      }
    });


    /*
    @locus Server
    @summary Returns array of fetched rows. If query was passed with `reactive` option - data will be updated each event loop.
    @name forEach
    @class Neo4jCursor
    @returns {[Object]} - Returns array of fetched rows
     */

    Neo4jCursor.prototype.fetch = function(firstOnly) {
      var data;
      data = [];
      this.forEach(function(row) {
        return data.push(row);
      }, firstOnly);
      return data;
    };


    /*
    @locus Server
    @summary Move cursor to first item and return it
    @name first
    @class Neo4jCursor
    @returns {[Object]} - Array of nodes or undefined if cursor has no items
     */

    Neo4jCursor.prototype.first = function() {
      this._current = 0;
      this.hasNext = this._cursor.length > 1 ? true : false;
      this.hasPrevious = false;
      return this._cursor[0];
    };


    /*
    @locus Server
    @summary Get current nodes on cursor
    @name current
    @class Neo4jCursor
    @returns {[Object]} - Array of nodes
     */

    Neo4jCursor.prototype.current = function() {
      return this._cursor[this._current];
    };


    /*
    @locus Server
    @summary Go to next item on cursor and return it
    @name next
    @class Neo4jCursor
    @returns {[Object]} - Array of nodes, or `undefined` if no next item
     */

    Neo4jCursor.prototype.next = function() {
      if (this.hasNext) {
        if (this._current <= this.length - 1) {
          ++this._current;
          this.hasNext = this._current === this.length - 1 ? false : true;
          this.hasPrevious = true;
          return this._cursor[this._current];
        }
      }
    };


    /*
    @locus Server
    @summary Go to previous item on cursor and return it
    @name previous
    @class Neo4jCursor
    @returns {[Object]} - Array of nodes, or `undefined` if no previous item
     */

    Neo4jCursor.prototype.previous = function() {
      if (this.hasPrevious) {
        if (this._current >= 1) {
          --this._current;
          this.hasNext = true;
          this.hasPrevious = this._current === 0 ? false : true;
          return this._cursor[this._current];
        }
      }
    };


    /*
    @locus Server
    @summary [EXPEMENETAL] Puts all unique nodes from current cursor into Mongo collection
    @name toMongo
    @class Neo4jCursor
    @param {Collection} MongoCollection - Instance of Mongo collection created via `new Mongo.Collection()`
    @returns {Collection}
     */

    Neo4jCursor.prototype.toMongo = function(MongoCollection) {
      var nodes;
      check(MongoCollection, Mongo.Collection);
      MongoCollection._ensureIndex({
        id: 1
      }, {
        background: true,
        sparse: true,
        unique: true
      });
      nodes = {};
      this.forEach(function(row) {
        var node, nodeAlias, _name, _ref2, _results;
        _results = [];
        for (nodeAlias in row) {
          node = row[nodeAlias];
          if (typeof node === "function" ? node(id) : void 0) {
            if (nodes[_name = node.id] == null) {
              nodes[_name] = {
                columns: [nodeAlias]
              };
            }
            nodes[node.id].columns = _.union(nodes[node.id].columns, [nodeAlias]);
            nodes[node.id] = _.extend(nodes[node.id], node);
            if ((_ref2 = nodes[node.id]) != null ? _ref2._service : void 0) {
              nodes[node.id]._service = void 0;
              delete nodes[node.id]._service;
            }
            _results.push(MongoCollection.upsert({
              id: node.id
            }, {
              $set: nodes[node.id]
            }));
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      });
      return MongoCollection;
    };


    /*
    @locus Server
    @summary Iterates thought Neo4j query results. And returns data as Neo4jData, Neo4jRelationship or Neo4jNode instance (depends from Cypher query). This function will move cursor to latest item.
    @name each
    @class Neo4jCursor
    @param {Function} callback - Callback function, with `node` (as Neo4jData, Neo4jRelationship or Neo4jNode instance), `num`, `cursor` arguments
    @returns {undefined}
     */

    Neo4jCursor.prototype.each = function(callback) {
      var first;
      check(callback, Function);
      if (this.length > 0) {
        first = true;
        while (this.hasNext || first) {
          if (first) {
            callback(this.first(), this._current, this._cursor);
            first = false;
          } else {
            callback(this.next(), this._current, this._cursor);
          }
        }
      }
    };


    /*
    @locus Server
    @summary Iterates though Neo4j query results. If query was passed with `reactive` option - data will be updated each event loop.
    @name forEach
    @class Neo4jCursor
    @param {Function} callback - Callback function, with `node` (plain object), `num`, `cursor` arguments
    @returns {undefined}
     */

    Neo4jCursor.prototype.forEach = function(callback, firstOnly) {
      var data, i, n, node, nodeAlias, r, row, rowId, _i, _j, _k, _len, _len1, _len2, _ref2;
      check(callback, Function);
      _ref2 = this.cursor;
      for (rowId = _i = 0, _len = _ref2.length; _i < _len; rowId = ++_i) {
        row = _ref2[rowId];
        data = {};
        if (_.isFunction(row != null ? row.get : void 0)) {
          data = row.get();
        } else if (_.isObject(row)) {
          for (nodeAlias in row) {
            node = row[nodeAlias];
            if (nodeAlias === 'nodes') {
              node = _.clone(node);
              for (i = _j = 0, _len1 = node.length; _j < _len1; i = ++_j) {
                n = node[i];
                if (n != null ? typeof n.get === "function" ? n.get() : void 0 : void 0) {
                  node[i] = n.get();
                }
              }
            }
            if (nodeAlias === 'relationships') {
              node = _.clone(node);
              for (i = _k = 0, _len2 = node.length; _k < _len2; i = ++_k) {
                r = node[i];
                if (r != null ? typeof r.get === "function" ? r.get() : void 0 : void 0) {
                  node[i] = r.get();
                }
              }
            }
            if (_.isFunction(node != null ? node.get : void 0)) {
              data[nodeAlias] = node.get();
            } else {
              data[nodeAlias] = node;
            }
          }
        }
        callback(data, rowId, this._cursor);
        if (firstOnly) {
          break;
        }
      }
    };

    return Neo4jCursor;

  })();

}).call(this);
